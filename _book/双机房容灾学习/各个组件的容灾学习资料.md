和宇云4.0之后开启了双中心容灾的设计



目前支持redis、kafka、fastdfs三个组件的容灾处理，两个机房的处理全局需依赖dns，通过域名来代替ip处理



容灾的处理大致分为，构建灾备组、正向同步、反向同步、提权、恢复、获取rpo时间的处理



#### redis双主模式

1、构建灾备组，并开启正向同步

在备机房的redis的节点上面执行，slaveof vip(主机房的vip的域名)

2、提权

在备机房的从节点上面执行，slaveof  no one 命令，会将备机房的从节点提权为主节点，同时配合dns完成切换

3、开启反向同步

反向同步其实就是主机房同步备机房数据，在主机房中的主节点上面执行，”slaveof 从机房域名“

4、恢复

恢复需要等待rpo的时间为0的时候，开启恢复的处理，

主机房的vip对应的主节点，执行slaveof  no one 命令，提升一下；备机房的节点执行slaveof vip(主机房的vip的域名)，恢复初始状态，同时配合dns完成切换



rpo时间的获取

![image-20210316105050189](各个组件的容灾学习资料.assets\image-20210316105050189.png)



#### redis集群模式

1、构建灾备组

属性设置cluster-slave-no-failover，cluster-replica-no-failover（> redis 5.0）配置为yes。禁用备机房各从节点自动故障迁移，确保在发生单点问题时备机房各从节点稳定提权。

属性详解：

![image-20210316120408499](各个组件的容灾学习资料.assets\image-20210316120408499.png)

2、提权

备机房从节点依次执行 cluster failover takeover 命令，手动故障转移，提权为主节点

命令详解：http://www.redis.cn/commands/cluster-failover.html

3、反向同步

第二步之后，如果主机房是正常运行情况，那么就已经是反向同步了

4、恢复

主机房原主节点依次执行 cluster failover 命令，恢复初始化状态。



rpo时间的获取

![image-20210316133907493](各个组件的容灾学习资料.assets\image-20210316133907493.png)



#### fastdfs模式

属性配置

需要在主机房的storage节点里面设置优先级，确保备机房storage的优先级低于主机房。

\#func：上传优先级。只有tracker.conf中store_server=2时，才有效。 

#valu：值约小，优先级越高。默认为10. upload_priority=10



1、构建灾备组

在构建之前都是相互独立的fastdfs高可用模式架构，构建灾备组，那么主备机房的storage节点都相互配置彼此机房的track地址（比如：如果两个机房分表是3台track，那么storage节点都配置6个track地址），都采取的域名模式。

2、正向同步，反向同步

当前是不需要处理的，fastdfs每一个storage组里面都是互相同步的

3、提权，恢复

这里就是修改优先级来实现的，那一边的优先级高，就是那边机房提供服务



rpo时间获取

通过fastdfs的监控来获取时间，执行命令如：fdfs_monitor /etc/fdfs/client.conf

获取每一个group的时间，对比获取最大的一个

![image-20210316135633857](各个组件的容灾学习资料.assets\image-20210316135633857.png)



#### kafka模式

kafka的双机房容灾通过mirrormaker2来实现

kafka2.7的版本才能同步消费者偏移量，需要使用2.7的版本



rpo的时间获取

这一块就需要通过api来获取，

方式：

获取两个机房Kafka 集群内部所有topic最新一条消息的时间戳。然后取其中的最大值。 rpo就是两个最大时间戳的差值 也相当于同步延迟时间

获取最新一条消息的方式是python脚本使用Kafka客户端先订阅主题。把消费者组偏移量重制到最新的那一条消息处。然后消费一次来获取到最新的那一条消息