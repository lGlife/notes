# MySQL服务器/客户端

## 简述

MySQL是 **C/S 架构**。

**mysql 服务器/客户端程序** 一般在 **MySQL安装目录/bin** 中。

## MySQL服务器程序

介绍主要执行MySQL服务器的程序或脚本：

- mysqld

  MySQL服务器程序。运行这个可执行文件可以直接启动MySQL服务器。

- mysql_safe

  它是一个启动脚本，它会间接调用mysqld并持续监控服务器运行状态。当服务器进程出现错误时，它还可以帮助重启服务器程序。另外使用mysql_safe启动MySQL服务器时，它会将服务器程序的出错信息和其他争端信息输出到错误日志。

- mysql.server

  它是一个启动脚本，它会间接调用mysqld_safe。

  执行方式：`mysql.server start`  `mysql.server stop`

  其实mysql.server是一个链接文件，对应的时间文件位于 ../support-files/mysql.server

## MySQL客户端程序

MySQL客户端程序有：mysql、mysqladmin、mysqldump等。这里主要介绍mysql。

连接MySQL服务器时参考执行：`mysql -h主机名 -u用户名 -p密码`

注意事项：

- -u 是 --user 的缩写，-p 是 --password 的缩写，其他类似缩写也有很多。**--** 双短横线是参数全称， **-** 单短横线是对应全称缩写。
- **-uroot  --user=root** -u后不能有空格

## 服务器与客户端连接过程

### TCP/IP

MySQL使用 TCP 作为服务器与客户端之间的网络通信协议。MySQL服务器默认监听3306端口。

### 命名管道和共享内存

**Windows系统可以使用**

#### 使用命名管道

- 启动服务器： `mysqld --enable-named-pipe`
- 启动客户端： `mysql --pipe` 或者 `mysql --procotol=pipe`

#### 使用共享内存

服务器与客户端**需要在一台Windows主机中**

- 启动服务器： `mysqld --shared-memory`
- 启动客户端不需要显式指定参数，如果要显式指定：`mysql --procotol=memory`

### UNIX域套接字

如果服务器和客户端都在一台Unix主机上，则可以使用 Unix 套接字进行进程间通信。如果在启动客户端时没有指定主机名，又或者指定为localhost，又或者指定了 `--procotol=socket` 参数，那么进程之间通过 Unix套接字 通信。

MySQL服务器默认监听的Unix套接字文件为 `/tmp/mysql.sock`，客户端也默认连接到这个文件。如果想改变默认监听的文件，可以在启动服务器时指定参数：

`mysqld --socket=/tmp/a.txt`

这样客户端想通过Unix域套接字通信也需要显式指定连接的Unix域套接字：

`mysql -uroot -p1234 --socket=/tmp/a.txt`

## 服务器处理客户端请求

MySQL服务器处理客户端请求按顺序有以下几步：

**第一部分：连接管理**

处理连接：每当有一个客户端连接到服务器时，服务器进程都会创建一个线程专门处理与这个客户端的交互；当客户端退出时会与服务器断开连接，而服务器并不会立刻销毁该线程，而是把它缓存起来，在另一个新客户端连接时，把这个缓存起来的线程分配给新客户端。这样不用频繁的创建和销毁线程，从而减小了开销。从这一点可以看出，每一个连接都有一个线程来管理，同时连接的数量太多会严重影响性能，所以需要限制同时连接到服务器的客户端数量。

然后便是用户名密码认证，认证失败则拒绝连接。如果客户端是远程连接，可以使用传输层安全性协议对连接进行加密，从而保证数据传输的安全性。

**第二部分：解析与优化**

查询缓存：简单来说，MySQL会把处理过的查询请求和结果缓存起来，当有下一个完全一样的查询请求时，直接返回缓存中的结果。

不过，如果两个查询请求有任何字符上的不同（空格、大写、回车等），或存在某些系统函数（now()等）、用户自定义变量和函数、系统表（），都会导致缓存不会命中。

MySQL的缓存系统会检测涉及的所有表，只要表的结果或数据被修改，则与该表有关的查询缓存都会无效并被删除。

因为要维护查询缓存的开销时常大于它所带来的性能提升，**从MySQL5.20开始不推荐使用查询缓存，MySQL8.0中被删除**。

语法解析：MySQL服务器会对客户端发送的文本进行解析，先判断语法，然后从文本中提取需要查询的表、列、查询条件等并放在MySQL内部使用的一些数据结构上。

查询优化：因为我们写的sql可能不是最好的，MySQL的优化程序会对语句做一些优化，如外连接转内连接等。优化的结果就是生成一个执行计划，我们可以使用 **EXPLAIN** 语句查看执行计划。

**第三部分：存储引擎**

真正保存数据的是存储引擎。

MySQL服务器的处理过程可以简单分为 server层和存储引擎层 ，上面的过程都是server的内容，我们把执行计划交给存储引擎去真正的对数据进行操作。

## 有关存储引擎的一些操作

### 查看存储引擎

`show engines`

### 设置表存储引擎

```sql
create table 表名(
	建表语句;
) engine = 存储引擎名
```

### 修改存储引擎

`alter table 表名 engine = 存储引擎名`

# Mysql配置与系统变量

## 启动选项和配置文件

启动选项和配置文件实际上都是修改了系统变量。

### 配置文件的搜索路径

#### Windows

| 路径                            | 备注                         |
| ------------------------------- | ---------------------------- |
| %WINDIR%\my.ini,%WINDIR%\my.cnf |                              |
| C:\my.ini,C:\my.cnf             |                              |
| BASEDIR\my.ini,BASEDIR\my.cnf   |                              |
| defaults-extra-file             | 命令行指定的额外配置文件路径 |
| %APPDATA%\MySQL\ .mylogin.cnf   | 登录路径选项（仅限客户端）   |

#### 类Unix

| 路径                | 备注                               |
| ------------------- | ---------------------------------- |
| /etc/my.cnf         |                                    |
| /etc/mysql/my/cnf   |                                    |
| SYSCONFDIR/my.cnf   |                                    |
| $MYSQL_HOME/my.cnf  | 特定于服务器登录选项（仅限服务器） |
| defaults-extra-file | 命令行指定额外配置文件路径         |
| ~/my.cnf            | 特定于用户选项                     |
| ~/mylogin.cnf       | 特定于用户的登录路径选项           |

### 配置文件的内容

与命令行不同的是，配置文件分为了若干个组。

```mysql
[server]
(启动选项)
option1          #这是选项1，该选项不需要值
option2=value    #这是选项2，该选项需要值
[mysqld]
(启动选项)
[client]
(启动选项)
[mysql]
(启动选项)
[......]
(......)
```

在配置文件中，不同的组给不同的程序读取，例如 mysqld 可以读取 [server]和[mysqld]组 。不过有两个组比较特别

- [server] 可以被所有服务器程序读取应用
- [client] 可以被所有客户端程序读取应用

### 配置文件优先级

MySQL会按照上文表中的搜索路径依次查找读取配置文件，如果该路径下文件不存在则忽略，多个配置文件中有重复的选项，则以最后一个生效。

### 同一配置文件多个组优先级

例如 mysqld 可以读取 [server]组和[mysqld]组 ，若这两个组有相同的启动选项，则以最后出现的为准生效。

### defaults-file的使用

若我们不想让MySQL到默认路径下搜索配置文件，则在命令行追加指定 `defaults-file` 选项。这样MySQL就会去指定路径查找配置文件。

## 系统变量

MySQL服务器在运行过程中有许多影响到程序行为的变量，它们被称为系统变量。

### 查看系统变量

`show variables [like 匹配的模式]`

show variables 显示所有的系统变量，但是太多了，一般需要使用 like 来匹配搜索。

### 设置系统变量

#### 通过启动选项设置

##### 命令行

`mysqld --default-storage-engine=MyISAM --max-connections=10`

##### 配置文件

```
[server]
default-storage-engine=MyISAM
max-connections=10
```

#### 服务器运行过程中设置

##### 设置不同范围系统变量

系统变量有作用范围之分：global（全局），session（会话）。

以设置默认存储引擎为例：

设置全局范围：

- `set global default_storage_engine=MySIAM;`
- `set @@global.default_storage_engine=MyISAM;`

设置会话范围：

- s`set session default_storage_engine=MySIAM;`
- set @@session.default_storage_engine=MyISAM;
- set default_storage_engine=MyISAM;

##### 查看不同范围的系统变量

`show [global|session] variables [like 匹配的模式]`

- global 修饰则显示全局范围的系统变量的值
- session 修饰则显示会话范围的系统变量的值
- 如果没写，则默认为 session 范围。

##### 注意事项

- 不是所有的系统变量都有全局范围和会话范围，有的只有全局范围（例如 max_connections），有的只有会话范围（例如 insert_id）。

- 有些系统变量是只读的，不可设置。

  比如 version 它表示MySQL版本，不能被修改。

## 启动选项和系统变量的区别

启动选项是程序启动时用户传递的一些参数，系统变量是影响服务器程序运行行为的变量。他们之间关系如下：

- 大部分系统变量都可以作为启动选项传入。
- 有些系统变量是在程序运行过程中自动生成的，不可以作为启动选项来设置，比如 character_set_client。
- 有些启动选项也不是系统变量，比如 defaults-file。

## 状态变量

**状态变量**描述了MySQL服务器的一些运行信息，可以让我们更了解当前服务器的状态。

例如：Threads_connected 表示当前有多少客户端连接MySQL服务器。

因为状态变量是根据服务器当前运行情况更改的，所以我们不能人为修改状态变量。与系统变量类似，状态变量也有**global和session**两个作用范围。

查看状态变量：

`show [global|session] status [like 匹配的模式]`

与查看系统变量类似，不写 global|session ，则表示查看 session 作用范围的状态变量。

# MySQL字符集和比较规则

MySQL支持n多种字符集，每种字符集下有n多种比较规则。通过字符集，MySQL能将二进制编码解码成人们能理解的文字。通过比较规则，MySQL能对这些字符进行排序。

## MySQL中的 utf8 和 utf8mb4

utf8使用变长编码方式，1~4 个字节表示一个字符。而MySQL中的定义有些许不同：

- utf8mb3：1~3 个字节表示一个字符。
- utf8mb4：1~4 个字节表示一个字符，传统意义上的 utf8。

而在 MySQL 中 utf8 指的是 utf8mb3，使用 1~3 个字节表示一个字符。如果数据库中的数据有需要 4 个字节表示一个字符的情况（如emoji表情），需要使用 utf8mb4.

## 字符集的查看

`show (character set|charset) [like 匹配的模式]`

character set 和 charset 是同义词，可以互相替换。

## 比较规则的查看

`show collation [like 匹配的模式]`

一种字符集可能有上十种比较规则。

![image-20210927144613479](E:\lzzData\study\mysql高级\mysql.assets\image-20210927144613479.png)

- 比较规则名称都以关联的字符集为开头

- 后缀表示规则应用的语言和是否区分语言的重音、大小写等。

  utf8mb4_general_ci：general 表示通用，ci 表示不区分大小写。

## 字符集和比较规则的应用

### 字符集和比较规则的级别

MySQL有四个级别的字符集和比较规则：

- 服务器级别：系统变量，可使用`show variables`查看，变量名：character_set_server，collation_server
- 数据库级别：创建或修改数据库时可以指定**数据库**的字符集和比较规则，如果不指定，则默认以服务器级别的字符集和比较规则创建数据库。系统变量，可使用`show variables`查看，查看前需要先`use database`，变量名：character_set_database，collation_database。
- 表级别：创建或修改表时可以指定**表**的字符集和比较规则，如不指定，则默认以数据库级别的字符集和比较规则创建表。
- 列级别：创建表或修改列时可指定**列**的字符集和比较规则，如不指定，则默认以表级别的字符集和比较规则创建列。

### 只修改字符集或比较规则

字符集和比较规则相互关联。只修改字符集，比较规则会自动修改为该字符集下默认比较规则；直接改比较规则，字符集也会改变为与该比较规则关联的字符集。

## 客户端与服务器通信过程使用的字符集

### 乱码问题

MySQL使用 utf8 编码下的 '我' 是的字节序列是 0xE68891（3字节） 。当我们使用 GBK 进行解码时，GBK以两个字节进行解码，最后会解出 '鎴'，并且还会多出一个字节无法解码。

### 字符集转码

如果把字节序列 0xE68891 按 utf8 解码得到 '我'，然后再把这个字符按照 gbk 进行编码得到 0xCED2。这个过程叫做字符集转码。

### 客户端与服务器通信的字符集转换过程

首先需要了解这几个系统变量，这些系统变量都是session范围：

| 系统变量                 | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| character_set_client     | 服务器认为请求是按照该系统变量指定的字符集进行编码的         |
| character_set_connection | 服务器在处理请求时，会把请求字节序列从character_set_client转换为character_set_connection |
| character_set_results    | 服务器采用该系统变量指定的字符集对返回给客户端的字符串进行编码 |

客户端发送一条字符串，一般来说，它是按照主机使用的字符集进行编码的。服务器使用 `character_set_client` 对客户端发送过来的字符串进行解码。此时如果`character_set_client`与客户端的字符集不一致时，就会出现乱码问题。之后在真正去处理请求的时候，又会将字符串转换为`character_set_connection`对应字符集进行编码的字节序列。在最后生成响应的时候，会把响应转换为以`character_set_results`对应字符集进行编码的字节序列，再发给客户端。

### 客户端收到响应

客户端收到的响应是一个**字节序列**。它依然需要以一个字符集解码，人们才看看懂它表达的意思。

- 对于类unix来说，会以unix自身默认的字符集进行解码。
- 对于类Windows来说，会使用客户端默认字符集进行解码。







# MySQL服务器/客户端

## 简述

MySQL是 **C/S 架构**。

**mysql 服务器/客户端程序** 一般在 **MySQL安装目录/bin** 中。

## MySQL服务器程序

介绍主要执行MySQL服务器的程序或脚本：

- mysqld

  MySQL服务器程序。运行这个可执行文件可以直接启动MySQL服务器。

- mysql_safe

  它是一个启动脚本，它会间接调用mysqld并持续监控服务器运行状态。当服务器进程出现错误时，它还可以帮助重启服务器程序。另外使用mysql_safe启动MySQL服务器时，它会将服务器程序的出错信息和其他争端信息输出到错误日志。

- mysql.server

  它是一个启动脚本，它会间接调用mysqld_safe。

  执行方式：`mysql.server start`  `mysql.server stop`

  其实mysql.server是一个链接文件，对应的时间文件位于 ../support-files/mysql.server

## MySQL客户端程序

MySQL客户端程序有：mysql、mysqladmin、mysqldump等。这里主要介绍mysql。

连接MySQL服务器时参考执行：`mysql -h主机名 -u用户名 -p密码`

注意事项：

- -u 是 --user 的缩写，-p 是 --password 的缩写，其他类似缩写也有很多。**--** 双短横线是参数全称， **-** 单短横线是对应全称缩写。
- **-uroot  --user=root** -u后不能有空格

## 服务器与客户端连接过程

### TCP/IP

MySQL使用 TCP 作为服务器与客户端之间的网络通信协议。MySQL服务器默认监听3306端口。

### 命名管道和共享内存

**Windows系统可以使用**

#### 使用命名管道

- 启动服务器： `mysqld --enable-named-pipe`
- 启动客户端： `mysql --pipe` 或者 `mysql --procotol=pipe`

#### 使用共享内存

服务器与客户端**需要在一台Windows主机中**

- 启动服务器： `mysqld --shared-memory`
- 启动客户端不需要显式指定参数，如果要显式指定：`mysql --procotol=memory`

### UNIX域套接字

如果服务器和客户端都在一台Unix主机上，则可以使用 Unix 套接字进行进程间通信。如果在启动客户端时没有指定主机名，又或者指定为localhost，又或者指定了 `--procotol=socket` 参数，那么进程之间通过 Unix套接字 通信。

MySQL服务器默认监听的Unix套接字文件为 `/tmp/mysql.sock`，客户端也默认连接到这个文件。如果想改变默认监听的文件，可以在启动服务器时指定参数：

`mysqld --socket=/tmp/a.txt`

这样客户端想通过Unix域套接字通信也需要显式指定连接的Unix域套接字：

`mysql -uroot -p1234 --socket=/tmp/a.txt`

## 服务器处理客户端请求

MySQL服务器处理客户端请求按顺序有以下几步：

**第一部分：连接管理**

处理连接：每当有一个客户端连接到服务器时，服务器进程都会创建一个线程专门处理与这个客户端的交互；当客户端退出时会与服务器断开连接，而服务器并不会立刻销毁该线程，而是把它缓存起来，在另一个新客户端连接时，把这个缓存起来的线程分配给新客户端。这样不用频繁的创建和销毁线程，从而减小了开销。从这一点可以看出，每一个连接都有一个线程来管理，同时连接的数量太多会严重影响性能，所以需要限制同时连接到服务器的客户端数量。

然后便是用户名密码认证，认证失败则拒绝连接。如果客户端是远程连接，可以使用传输层安全性协议对连接进行加密，从而保证数据传输的安全性。

**第二部分：解析与优化**

查询缓存：简单来说，MySQL会把处理过的查询请求和结果缓存起来，当有下一个完全一样的查询请求时，直接返回缓存中的结果。

不过，如果两个查询请求有任何字符上的不同（空格、大写、回车等），或存在某些系统函数（now()等）、用户自定义变量和函数、系统表（），都会导致缓存不会命中。

MySQL的缓存系统会检测涉及的所有表，只要表的结果或数据被修改，则与该表有关的查询缓存都会无效并被删除。

因为要维护查询缓存的开销时常大于它所带来的性能提升，**从MySQL5.20开始不推荐使用查询缓存，MySQL8.0中被删除**。

语法解析：MySQL服务器会对客户端发送的文本进行解析，先判断语法，然后从文本中提取需要查询的表、列、查询条件等并放在MySQL内部使用的一些数据结构上。

查询优化：因为我们写的sql可能不是最好的，MySQL的优化程序会对语句做一些优化，如外连接转内连接等。优化的结果就是生成一个执行计划，我们可以使用 **EXPLAIN** 语句查看执行计划。

**第三部分：存储引擎**

真正保存数据的是存储引擎。

MySQL服务器的处理过程可以简单分为 server层和存储引擎层 ，上面的过程都是server的内容，我们把执行计划交给存储引擎去真正的对数据进行操作。

## 有关存储引擎的一些操作

### 查看存储引擎

`show engines`

### 设置表存储引擎

```sql
create table 表名(
	建表语句;
) engine = 存储引擎名
```

### 修改存储引擎

`alter table 表名 engine = 存储引擎名`

# Mysql配置与系统变量

## 启动选项和配置文件

启动选项和配置文件实际上都是修改了系统变量。

### 配置文件的搜索路径

#### Windows

| 路径                            | 备注                         |
| ------------------------------- | ---------------------------- |
| %WINDIR%\my.ini,%WINDIR%\my.cnf |                              |
| C:\my.ini,C:\my.cnf             |                              |
| BASEDIR\my.ini,BASEDIR\my.cnf   |                              |
| defaults-extra-file             | 命令行指定的额外配置文件路径 |
| %APPDATA%\MySQL\ .mylogin.cnf   | 登录路径选项（仅限客户端）   |

#### 类Unix

| 路径                | 备注                               |
| ------------------- | ---------------------------------- |
| /etc/my.cnf         |                                    |
| /etc/mysql/my/cnf   |                                    |
| SYSCONFDIR/my.cnf   |                                    |
| $MYSQL_HOME/my.cnf  | 特定于服务器登录选项（仅限服务器） |
| defaults-extra-file | 命令行指定额外配置文件路径         |
| ~/my.cnf            | 特定于用户选项                     |
| ~/mylogin.cnf       | 特定于用户的登录路径选项           |

### 配置文件的内容

与命令行不同的是，配置文件分为了若干个组。

```mysql
[server]
(启动选项)
option1          #这是选项1，该选项不需要值
option2=value    #这是选项2，该选项需要值
[mysqld]
(启动选项)
[client]
(启动选项)
[mysql]
(启动选项)
[......]
(......)
```

在配置文件中，不同的组给不同的程序读取，例如 mysqld 可以读取 [server]和[mysqld]组 。不过有两个组比较特别

- [server] 可以被所有服务器程序读取应用
- [client] 可以被所有客户端程序读取应用

### 配置文件优先级

MySQL会按照上文表中的搜索路径依次查找读取配置文件，如果该路径下文件不存在则忽略，多个配置文件中有重复的选项，则以最后一个生效。

### 同一配置文件多个组优先级

例如 mysqld 可以读取 [server]组和[mysqld]组 ，若这两个组有相同的启动选项，则以最后出现的为准生效。

### defaults-file的使用

若我们不想让MySQL到默认路径下搜索配置文件，则在命令行追加指定 `defaults-file` 选项。这样MySQL就会去指定路径查找配置文件。

## 系统变量

MySQL服务器在运行过程中有许多影响到程序行为的变量，它们被称为系统变量。

### 查看系统变量

`show variables [like 匹配的模式]`

show variables 显示所有的系统变量，但是太多了，一般需要使用 like 来匹配搜索。

### 设置系统变量

#### 通过启动选项设置

##### 命令行

`mysqld --default-storage-engine=MyISAM --max-connections=10`

##### 配置文件

```
[server]
default-storage-engine=MyISAM
max-connections=10
```

#### 服务器运行过程中设置

##### 设置不同范围系统变量

系统变量有作用范围之分：global（全局），session（会话）。

以设置默认存储引擎为例：

设置全局范围：

- `set global default_storage_engine=MySIAM;`
- `set @@global.default_storage_engine=MyISAM;`

设置会话范围：

- s`set session default_storage_engine=MySIAM;`
- set @@session.default_storage_engine=MyISAM;
- set default_storage_engine=MyISAM;

##### 查看不同范围的系统变量

`show [global|session] variables [like 匹配的模式]`

- global 修饰则显示全局范围的系统变量的值
- session 修饰则显示会话范围的系统变量的值
- 如果没写，则默认为 session 范围。

##### 注意事项

- 不是所有的系统变量都有全局范围和会话范围，有的只有全局范围（例如 max_connections），有的只有会话范围（例如 insert_id）。

- 有些系统变量是只读的，不可设置。

  比如 version 它表示MySQL版本，不能被修改。

## 启动选项和系统变量的区别

启动选项是程序启动时用户传递的一些参数，系统变量是影响服务器程序运行行为的变量。他们之间关系如下：

- 大部分系统变量都可以作为启动选项传入。
- 有些系统变量是在程序运行过程中自动生成的，不可以作为启动选项来设置，比如 character_set_client。
- 有些启动选项也不是系统变量，比如 defaults-file。

## 状态变量

**状态变量**描述了MySQL服务器的一些运行信息，可以让我们更了解当前服务器的状态。

例如：Threads_connected 表示当前有多少客户端连接MySQL服务器。

因为状态变量是根据服务器当前运行情况更改的，所以我们不能人为修改状态变量。与系统变量类似，状态变量也有**global和session**两个作用范围。

查看状态变量：

`show [global|session] status [like 匹配的模式]`

与查看系统变量类似，不写 global|session ，则表示查看 session 作用范围的状态变量。

# MySQL字符集和比较规则

MySQL支持n多种字符集，每种字符集下有n多种比较规则。通过字符集，MySQL能将二进制编码解码成人们能理解的文字。通过比较规则，MySQL能对这些字符进行排序。

## MySQL中的 utf8 和 utf8mb4

utf8使用变长编码方式，1~4 个字节表示一个字符。而MySQL中的定义有些许不同：

- utf8mb3：1~3 个字节表示一个字符。
- utf8mb4：1~4 个字节表示一个字符，传统意义上的 utf8。

而在 MySQL 中 utf8 指的是 utf8mb3，使用 1~3 个字节表示一个字符。如果数据库中的数据有需要 4 个字节表示一个字符的情况（如emoji表情），需要使用 utf8mb4.

## 字符集的查看

`show (character set|charset) [like 匹配的模式]`

character set 和 charset 是同义词，可以互相替换。

## 比较规则的查看

`show collation [like 匹配的模式]`

一种字符集可能有上十种比较规则。

![image-20210927144613479](E:\lzzData\study\mysql高级\mysql.assets\image-20210927144613479.png)

- 比较规则名称都以关联的字符集为开头

- 后缀表示规则应用的语言和是否区分语言的重音、大小写等。

  utf8mb4_general_ci：general 表示通用，ci 表示不区分大小写。

## 字符集和比较规则的应用

### 字符集和比较规则的级别

MySQL有四个级别的字符集和比较规则：

- 服务器级别：系统变量，可使用`show variables`查看，变量名：character_set_server，collation_server
- 数据库级别：创建或修改数据库时可以指定**数据库**的字符集和比较规则，如果不指定，则默认以服务器级别的字符集和比较规则创建数据库。系统变量，可使用`show variables`查看，查看前需要先`use database`，变量名：character_set_database，collation_database。
- 表级别：创建或修改表时可以指定**表**的字符集和比较规则，如不指定，则默认以数据库级别的字符集和比较规则创建表。
- 列级别：创建表或修改列时可指定**列**的字符集和比较规则，如不指定，则默认以表级别的字符集和比较规则创建列。

### 只修改字符集或比较规则

字符集和比较规则相互关联。只修改字符集，比较规则会自动修改为该字符集下默认比较规则；直接改比较规则，字符集也会改变为与该比较规则关联的字符集。

## 客户端与服务器通信过程使用的字符集

### 乱码问题

MySQL使用 utf8 编码下的 '我' 是的字节序列是 0xE68891（3字节） 。当我们使用 GBK 进行解码时，GBK以两个字节进行解码，最后会解出 '鎴'，并且还会多出一个字节无法解码。

### 字符集转码

如果把字节序列 0xE68891 按 utf8 解码得到 '我'，然后再把这个字符按照 gbk 进行编码得到 0xCED2。这个过程叫做字符集转码。

### 客户端与服务器通信的字符集转换过程

首先需要了解这几个系统变量，这些系统变量都是session范围：

| 系统变量                 | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| character_set_client     | 服务器认为请求是按照该系统变量指定的字符集进行编码的         |
| character_set_connection | 服务器在处理请求时，会把请求字节序列从character_set_client转换为character_set_connection |
| character_set_results    | 服务器采用该系统变量指定的字符集对返回给客户端的字符串进行编码 |

客户端发送一条字符串，一般来说，它是按照主机使用的字符集进行编码的。服务器使用 `character_set_client` 对客户端发送过来的字符串进行解码。此时如果`character_set_client`与客户端的字符集不一致时，就会出现乱码问题。之后在真正去处理请求的时候，又会将字符串转换为`character_set_connection`对应字符集进行编码的字节序列。在最后生成响应的时候，会把响应转换为以`character_set_results`对应字符集进行编码的字节序列，再发给客户端。

### 客户端收到响应

客户端收到的响应是一个**字节序列**。它依然需要以一个字符集解码，人们才能看懂它表达的意思。

- 对于类unix来说，会以unix自身默认的字符集进行解码。
- 对于类Windows来说，会使用客户端默认字符集进行解码。

## 比较规则的应用

在类似`select * from t order by col`的SQL语句，我们需要以结果的某一列进行排序。

这个时候便应用到了比较规则，不同的比较规则的排序结果可能不一样。

# InnoDB记录存储结构

InnoDB是一种持久化存储引擎。InnoDB以页作为内存和磁盘数据交换的基本单位，InnoDB一页一般为 **16KB**。也就是说，一次从磁盘最少读取16KB到内存中，一次从内存最少刷新16KB到磁盘中。

## InnoDB行格式

记录在表中的存放形式被称为**记录格式**或**行格式**，目前InnoDB有四种不同类型的行格式：`COMPACT、REDUNDANT、DYNAMIC、COMPRESSED`。

主要介绍 **COMPACT** 行格式，其余行格式万变不离其宗。

## 指定行格式

可以在创建或修改表时指定记录所使用的行格式：

```sql
create table 表名 (列信息) row_format=行格式名称
alter table 表名 row_format=行格式名称
```

## COMPACT行格式

如图所示，一条记录分为记录的额外信息（红色部分）和记录的真实数据（黑色部分）。

![image-20210928112109128](D:\A-资料文档\E-文档编写笔记文件夹\typora笔记\其他杂事\mysql学习笔记.assets\image-20210928112109128.png)

### 记录的额外信息

为了更方便的管理记录而额外添加的一些信息

#### 变长字段长度列表

在COMPACT行格式中，所有变长字段的真实数据所占用的字节数都会 **逆序存放** 到变长字段长度列表中。

当变长字段最大可容纳字节数 <=255 时，使用 1 个字节表示该变长字段真实数据所占字节数。

当变长字段最大可容纳字节数 > 255 时，分为两种情况：

- 该变长字段真实数据占用字节数 <= 127 ，使用 1 个字节表示真实数据占用字节数。
- 该变长字段真实数据占用字节数 > 127 ，使用 2 个字节表示真实数据占用字节数。

若该变长字段的真实数据为空，不会在变长字段长度列表中存储占用字节数。

#### NULL值列表

COMPACT行格式会把一条记录中值为 NULL 的记录统一存储到空值列表。

- 二进制的值为 **1**，代表该列为 **NULL**
- 二进制的值为 **0**，代表该列 **非NULL**
- 二进制位按照列的顺序 **逆序排列**
- MySQL规定 NULL值列表必须用整数个字节的位表示，若当前 使用的二进制位数不足整数个字节，则高位补0。

#### 记录头信息

记录头信息由 5 个字节组成，也就是 40 个二进制位。用于描述记录的一些属性。

| 名称         | 大小（位） | 描述                                                         |
| ------------ | ---------- | ------------------------------------------------------------ |
| 预留位1      | 1          | 没有使用                                                     |
| 预留位2      | 1          | 没有使用                                                     |
| deleted_flag | 1          | 标记该记录是否被删除                                         |
| min_rec_flag | 1          | B+树的每层非叶子节点中最小的目录项记录都会添加该标记         |
| n_owned      | 4          | 一个页面的记录会被分为若干个组，每个组中有一个记录（最大的记录）的 n_owned 值代表该组中所有的记录条数，该组其他记录的 n_owned 值为0 |
| heap_no      | 13         | 表示当前记录在页面堆中的相对位置                             |
| record_type  | 3          | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点的目录项记录，2表示Infimum记录，3表示Supremum记录 |
| next_record  | 16         | 表示下一条记录的相对位置                                     |

### 记录的真实数据

#### 隐藏列

表中记录的真实数据除了我们自己定义的数据外，MySQL会为每一条记录额外添加一些列（也叫做隐藏列）：

| 列名        | 是否必需 | 占用空间 | 描述                   |
| ----------- | -------- | -------- | ---------------------- |
| DB_ROW_ID   | 否       | 6字节    | 行ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6字节    | 事务ID                 |
| DB_ROLL_PTR | 是       | 7字节    | 回滚指针               |

关于 DB_ROW_ID：InnoDB的主键生成策略中，优先使用用户自定义的主键作为主键，如果用户没有定义主键，则选取一个不允许存储 NULL 值的 UNIQUE 键作为主键；如果表中连不允许为 NULL 的 UNIQUE 的键都没有定义，则 InnoDB为默认为表添加一个名为 DB_ROW_ID 的隐藏列作为主键。

#### CHAR(M)列的存储格式

上面介绍了都是变长字段的真实数据字节数都会存储在 **变长长度列表中**，而CHAR(M)列的真实数据字节数不会在该列表存储。这句话在这些列使用的字符集是 **定长编码字符集**（例如：ascii） 下是成立的。

而当 CHAR(M) 的列使用变长编码字符集（例如：utf8）时，该列也会**存储**真实数据的字节数进变长字段长度列表中。

还有一点需要注意：CHAR(M) 列使用变长编码字符集时，该列至少要占用 M 个字节。以使用 utf8 字符集的 CHAR(10) 列为例，该列存储数据占用长度范围为 10-30 个字节，即使我们存储空字符串，也会占用 10 个字节。

## REDUNDANT行格式

REDUNDANT 与 COMPACT 有许多相似之处，REDUNDANT 是MySQL 5.0以前使用的行格式。

REDUNDANT 的逻辑结构：

- 字段长度偏移列表
- 记录头信息
- 列1……列n的值

### 字段长度偏移列表

字段偏移列表会把这一条记录的**所有列的偏移量**都**逆序**存储进来。

要计算字段长度，需要 **该列的字段偏移量减去前一列的字段偏移量**

### 记录头信息

REDUNDANT 记录头信息占用6字节

| 名称            | 大小（位） | 描述                                                         |
| --------------- | ---------- | ------------------------------------------------------------ |
| 预留位1         | 1          | 没有使用                                                     |
| 预留位2         | 1          | 没有使用                                                     |
| deleted_flag    | 1          | 标记记录是否被删除                                           |
| min_rec_flag    | 1          | B+树的每层非叶子节点中的最小目录项记录会添加该标记           |
| n_owned         | 4          | 一个页面的记录会被分为若干个组，每个组中有一个记录（最大的记录）的 n_owned 值代表该组中所有的记录条数，该组其他记录的 n_owned 值为0 |
| heap_no         | 13         | 表示当前记录在页面堆中的相对位置                             |
| n_field         | 10         | 表示记录中列的数量                                           |
| 1byte_offs_flag | 1          | 标记字段长度偏移量列表中每个列对应的偏移量是使用1字节还是2字节表示的 |
| next_record     | 16         | 表示下一条记录的绝对位置                                     |

1byte_offs_flag值的选取：

当记录的全部真实数据字节数 <=127 ，字段长度偏移量列表用 1 字节表示。

当记录的全部真实数据字节数 >127 且 <=32767，字段长度偏移量列表用 2 字节表示。

列中NULL值的处理：

为什么 1byte_offs_flag 以 127 为分界？因为 REDUNDANT 使用 字段长度偏移量列表 的 **第一位** 表示该列是否为 NULL。

1表示该列为 NULL ，0表示 非NULL。

### 定长类型的列

定长类型的列即使为空，也会占用该字段的最大容纳空间的字节数。

假设一个 utf8 CHAR(10) 的列为空，它也会占用 30个字节。REDUNDANT 会以 `000......000`填充满该列。

## 溢出列

InnoDB一页的数据是16KB；对于 COMPACT 和 REDUNDANT ，当一列的数据过大导致这一列都很难存储这条记录时，那么该列的真实数据处只会**存储部分数据（768字节）**，剩余的数据会分散在其他页中，并在该列的真实数据处用 20 字节存储指向这些页面的地址和这些数据占用的字节数。

如果一列的数据需要使用溢出页来存储，那么该列就叫溢出列（off-page列）

### 产生溢出列的临界点

- 每一页除了记录占用的字节数外，还会存储与页有关的信息，需要 132 字节

- 每个记录需要的额外信息是 27 字节（CONPACT行格式）

- MySQL规定一页最少存储两条记录

- 假设该表只有一列，该列真实数据占用的字节数为 n ，则需要满足下面不等式

  132+2×(27+n)<16384

## DYNAMIC行格式和COMPRESSED行格式

DYNAMIC行格式和COMPRESSED行格式 对于溢出列不会在该列的真实数据处存储前768个字节的数据，仅存储20字节大小指向溢出页的地址。

COMPRESSED行格式还会采用压缩算法对页面进行压缩。



# InnoDB数据页结构

## InnoDB数据页结构

| 名称             | 中文名                     | 占用空间大小 | 简单概述             |
| ---------------- | -------------------------- | ------------ | -------------------- |
| File Header      | 文件头部                   | 38字节       | 页的一些通用信息     |
| Page Header      | 页面头部                   | 56字节       | 数据页专有的一些信息 |
| Infimum+Supremum | 页面中的最小记录和最大记录 | 26字节       | 两个虚拟记录         |
| User Records     | 用户记录                   | 不确定       | 用户存储的记录内容   |
| Free Space       | 空闲空间                   | 不确定       | 页面中尚未使用的空间 |
| Page Directory   | 页目录                     | 不确定       | 页中某些记录的位置   |
| File Trailer     | 文件尾部                   | 8字节        | 校验页是否完整       |

## 记录在页中的存储

- 记录存储在页中的**User Records**中，每插入一条记录，都会划分一个新的空间，当Free Space不够时，会开辟新的页。
- 记录在页中的存储是物理上连续的。
- 记录在页中按照**主键顺序存储**。
- 当我们删除一条记录时，记录并不会马上在磁盘上被删除；它记录头信息的**deleted_flag**会被标记为 **1** 。之所以不在磁盘上马上移除，是因为还需要在磁盘重新排列其他记录，有性能损耗。所有被删除的记录会形成一个垃圾链表，记录在这个链表中占用的空间称为可重用空间。之后若有新纪录插入到表中，它们就有可能覆盖掉被删除的这些记录占用的存储空间。
- 记录在堆（记录的存储结构）的相对位置称为 **heap_no**
- 页中有两条特殊的记录：Infimum 和 Supremum。任何用户记录都比 Infimum 大，都比 Supremum 小。
- next_record：表示当前记录真实数据到下一条记录真实数据的距离。

## 页目录

为了提高查找速率，InnoDB设计者设计了页目录：

- 将所有正常记录（包括 Infimum 和 Supremum 记录，不包括有已删除标记的记录）分为至少两个组。Infimum 单独为一组，Supremum组记录在 1~8 条之间，其余组记录在 4~8 条之间。
- 每组最后一条记录的记录头信息中的 n_owned 属性表示该组有几条记录。
- 把每组最后一条记录在页中的地址偏移量单独提取出来，按顺序存储在靠近页面尾部的地方，这个地方就是 **页目录** ，页目录的这些地址偏移量称为 **槽** 。每个槽占用 2 个字节。

查找时，使用二分法查找与主键对应的槽，再通过槽进入组中使用 **next_record** 进行遍历。

## Page Header（页面头部）

用于存储数据页中记录的状态信息，占用56字节。

| 状态名称          | 占用空间大小 | 描述                                                         |
| ----------------- | ------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2字节        | 在页目录中的槽数量                                           |
| PAGE_HEAP_TOP     | 2字节        | 还未使用的空间的最小地址，从该地址之后就是Free Space         |
| PAGE_N_HEAP       | 2字节        | 第1位表示本记录是否为紧凑型记录，剩余的15位表示本页的堆中记录的数量（包括 Infimum 和 Supremum 记录和标记为 已删除 的记录） |
| PAGE_FREE         | 2字节        | 各个已删除的记录通过 next_record 组成的一个单向链表，PAGE_FREE 表示该单向链表头节点对应记录在页面中的偏移量 |
| PAGE_GARBAGE      | 2字节        | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2字节        | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2字节        | 记录插入的方向                                               |
| PAGE_N_DIRECTION  | 2字节        | 一个方向连续插入的记录数量                                   |
| PAGE_N_RECS       | 2字节        | 该页中用户记录的数量（不包括 Infimum 和 Supremum 以及被删除的记录） |
| PAGE_MAX_TRX_ID   | 8字节        | 修改当前页的最大事务ID，该值仅在二级索引页面中定义           |
| PAGE_LEVEL        | 2字节        | 当前页在B+树所处的层级                                       |
| PAGE_INDEX_ID     | 8字节        | 索引ID，表示当前页属于哪个索引                               |
| PAGE_BTR_SEG_LEAF | 10字节       | B+树叶子节点段的头部信息，仅在B+树的根页面中定义             |
| PAGE_BTR_SEG_TOP  | 10字节       | B+树叶子非节点段的头部信息，仅在B+树的根页面中定义           |

## File Header（文件头部）

描述数据页的通用信息，占用38字节。

| 状态名称                         | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4字节        | MySQL版本低于4.0.14时，表示本页面所在的表空间ID；之后的版本表示页的校验和 |
| FIL_PAGE_OFFSET                  | 4字节        | 页号                                                         |
| FIL_PAGE_PREV                    | 4字节        | 上一页的页号                                                 |
| FIL_PAGE_NEXT                    | 4字节        | 下一页的页号                                                 |
| FIL_PAGE_LSN                     | 8字节        | 页面最后被修改对应的LSN（Log Sequence Number，日志序列号）值 |
| FIL_PAGE_TYPE                    | 2字节        | 该页的类型                                                   |
| FIL_PAGE_FILE_FLUSH_LSN          | 8字节        | 仅在系统表空间的第一个页中定义，代表文件至少刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4字节        | 页属于那个表空间                                             |

## File Trailer（文件尾部）

当内存将数据刷新到磁盘中，如果在刷新一半的时候主机断电会导致数据页不完整。

File Trailer 由 8 个字节组成，可以分为两个部分：

- 前 4 字节代表校验和。与 File Header 的校验和相对应。当内存中数据刷新到磁盘时，会先计算校验和，因为FIle Header在前面，所以File Header的校验和首先刷新到磁盘，当完全写完后，File Trailer的校验和也会被刷新到磁盘。如果成功写入，那么两个校验和应该是一样的。不过两个校验和不匹配，说明写入期间发生了错误。
- 后 4 字节表示页面被最后修改时的 LSN 的后 4 字节，正常情况下应该与 File Header 的 FIL_PAGE_LSN后 4 字节相同。